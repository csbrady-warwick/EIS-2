# Using the EIS parser

## Concepts

The core of the EIS parser is a parser object called an `eis_parser`. You then hand this parser a mathematical expression as a string and it either evaluates that string directly to an array of numbers or an `eis_stack` object that can be evaluated multiple times without the overhead of parsing the string again. When you evaluate a string or a stack you can optionally pass it an object that contains information provided by the host code rather than directly read in from the user. None of the built in routines make use of this information because it is entirely specified by the host code. This object might, for example, contain information about where in space a stack should be evaluated and you could add functions or variables that give a different result based on the values in this object

## Terms

Parser - A single instance of the `eis_parser` type

Expression - A string to be parsed by the parser

Stack - An instance of the `eis_stack` type representing a parsed expression

Tokenization - Converting an expression into a stack

Evaluation - Converting either an Expression or a Stack into an array of numerical results

Literal  - A numerical value entered directly into the text to be parsed as a number (e.g. 1)

Constant - A value known by name to the parser to be always a fixed numerical value (e.g. kb for Boltzmann's constant)

Host Parameters - An object given by the host code that is available to all of the routines that evaluate the parts of a stack

Variable - A value known by name to the parser but where the value of it can only be determined when the stack is created or evaluated. It cannot take any parameters from the user but will in general use the host parameters

Stack Variable - A preexisting stack that is known by name to the parser. When the name is encounted the stack is placed into the new expression at the location of the name. This means that a mathematical expression can be stored and then reused in other expressions

Function - A routine known by name to the parser that takes a number of parameters from the user before evaluating

Variadic Function - A function that takes as many parameters as it is given rather than expecting a fixed number

Parser Item - A Function, Variable, Stack Variable or Constant

Deck Variable - A stack that is known by name to the parser so that it can be used in other expressions

Deferred - A Function, Variable or Constant that is assigned a name not assigned an evaluation function or value when it is first registered. A defered but can be used to create stacks anyway. An evaluation function or value must be assigned before the stack can be evaluated

Emplaced - A function that should return a stack rather than a value when it is evaluated. The stack is then put into place

Capability bits - Any variable, function or constant can have capability bits associated with them. These capability bits are combined when a stack is parsed and the capability bits of the stack is the bitwise OR of the capability bits of it's contents

Description - A text description of a token given when it is added to the parser
## Simple EIS parser program

The simplest parser program is just a glorified calculator and that can be implemented very easily indeed. You simply have to create a parser object and call it's 'evaluate' function. The evaluate function takes either a pretokenized stack (if you want to evaluate the same expression multiple times) or a string (for one off evaluation). It also takes an allocatable REAL array of kind `eis_num` that it will fill with the results of evaluating your stack. If the array handed to it is not allocated or not large enough to hold the number of returned items then it will be reallocated as needed. The number of results actually generated by the evaluation is returned from the function. The final parameter to evaluate is the error code which is an INTEGER of kind `eis_error`. This result is a bitmask that details the location and type of the error, but in general most codes will only want to check if it is the special value `eis_err_none`, and if it isn't then obtain the error report from the parser. The following code snippet shows how to use EIS as a simple calculator which will keep taking strings to evaluate until the program is killed.

```fortran
PROGRAM test

  USE eis_parser_header
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct

  PRINT *, 'This example uses the base parser to calculate maths expressions'
  DO WHILE(.TRUE.)
    WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
    READ(*,'(A)') input
    ct = parser%evaluate(input, result, errcode)
    IF (errcode == eis_err_none) THEN
      PRINT *,'Result is ', result(1:ct)
    ELSE
      CALL parser%print_errors()
    END IF
  END DO

END PROGRAM test

```

## Using stacks to separate tokenization and evaluation
At the most basic level EIS Parser is a fairly simple combination of two things:
1. An implementation of Dijkstra's Shunting Yard Algorithm to convert the normal infix maths notation that the user enters into reverse Polish notation. At the same time it is converted from text to a stream of tokens that say what functions should be called to evaluate the expression. 
2. An RPN calculator to evaluate the token stream into a set of numbers

EIS is more complicated than this in various ways but that is a good approximation to its core. A fairly large chunk of the time taken to evaluate EIS expressions is the time taken to convert the text expression that the user enters into the token stream and if you are repeatedly executing the same expression you will probably want to avoid this overhead. You do this by using the `tokenize` method of the parser object to create an `eis_stack` object and then using the same `evaluate` method every time you evaluate the expression.

```fortran
PROGRAM test

  USE eis_parser_header
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  TYPE(eis_stack) :: stored_value
  INTEGER :: ct

  PRINT *,'This is the same problems as demo1 but tokenizes the expression to &
      &a stack so that it can be evaluated multiple times (although it isn`t &
      &in this example)'
  DO WHILE(.TRUE.)
    WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
    READ(*,'(A)') input
    CALL parser%tokenize(input, stored_value, errcode)
    IF (errcode /= eis_err_none) THEN
      CALL parser%print_errors()
      STOP
    END IF
    ct = parser%evaluate(stored_value, result, errcode)
    IF (errcode == eis_err_none) THEN
      PRINT *,'Result is ', result(1:ct)
    ELSE
      CALL parser%print_errors()
    END IF
  END DO

END PROGRAM test

```

## EIS performance

An important question is approximately how fast is each operation in an EIS expression evaluated. EIS is interpreted so it will be substantially slower than native code, especially since it evaluates numbers in a scalar rather than vector manner. Performance will depend on your compiler (especially how well it performs with OO Fortran code) and the performance of your machine. To give a rough estimate, on an AMD Ryzen Threadripper 1950X compiling with gfortran 9 a single core at 4GHz executes EIS stacks at about 10ns/operation. This means that is takes about 40 CPU cycles per operation and this result seems to be similar on other platforms.

## Selecting a physics package

EIS includes several common physical constants built in but by default they are only available by typing their full name. To make them easily available you have to manually initialise the parser with a physics constant. This is easy to do. Before you use the parser for any other purpose simply issue the init instruction

```fortran
CALL parser%init(errcode)
```

Once again `errcode` is an integer of kind `eis\_error\_kind`. On it's own this function doesn't do much because the parser performs this type of minimal initialization if needed when it is first used. You can optionally specify several commands to the init routine but here we want to specify the physics type. You can run either of

```fortran
CALL parser%init(errcode, physics = eis_physics_si)
CALL parser%init(errcode, physics = eis_physics_cgs_gaussian)
```

The former will load the physical constants in SI into the default known constants and the second CGS Gaussian units. Other physics models may be added later.

If you want to access a physical constant without setting up a global physics model or want to access constants from a different physics model than the one selected then you have to use the full name. The full names are the names of the constants (see list of physical constants) but prepended with either

1) physics.si. (e.g. physics.si.kb is Boltzmann's constant)

2) physics.cgs.gaussian. (eg. physics.cgs.gaussian.kb is Boltzmann's constant)

## Adding a constant

EIS comes with a decent list of physical and mathematical constants built in but one of the most common things to want to do is to add extra constants. This is done easily by adding a call to the "add\_constant" method of the parser object. Constants can be either `REAL(KIND=eis_num)` or 4 or 8 byte integers.

```fortran
PROGRAM test

  USE eis_parser_header
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct

  PRINT *, 'This example adds a named constant `myconstant`. It always has &
      &the same value (1.2345) but works without a getter function.'

  CALL parser%add_constant('myconstant', 1.2345_eis_num, errcode)
  IF (errcode /= eis_err_none) CALL parser%print_errors()

  DO WHILE(.TRUE.)
    WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
    READ(*,'(A)') input
    ct = parser%evaluate(input, result, errcode)
    IF (errcode == eis_err_none) THEN
      PRINT *,'Result is ', result(1:ct)
    ELSE
      CALL parser%print_errors()
    END IF
  END DO

END PROGRAM test

```

You can then access the value 'myconstant' by name in a deck expression and the value 1.2345 will be used for that value. Since the EIS parser uses real numbers internally if you specify an integer constant it is converted into the closest representable real number of kind eis\_num.

## Adding variables

Constants are just names that map to fixed values. If you want to (potentially) return a different value each time that a name is used in an expression then you want to specify a variable. Variables are returned by you specifying a getter function rather than from a fixed value. The getter functions look like

```fortran
  FUNCTION getter(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
```

The getter functions are used in several places in the EIS parser and almost all of the parameters are not needed for specifying variables. The main thing for specifying a variable is just to return the value of the variable. The other thing that is very important to note is that this is a `BIND(C)` function, meaning that it is a Fortran/C interoperable function. This is so that you can freely use functions from C or Fortran as getter functions without any performance cost from identifying whether to call the C or the Fortran version of the getter function. To specify the function you use the `add_variable` method of the parser object. It has much the same signature as the `add_constant` method but you put the getter function in in place of the value of the constant. The following example has a simple variable called `myvar` that returns a value that increased by one every time it is evaluated (with a caveat covered in the next example).

```fortran
MODULE mymod

  USE ISO_C_BINDING
  USE eis_parser_header

  CONTAINS

  FUNCTION get_var(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
    REAL(eis_num) :: store = 0.0_eis_num

    store = store + 1.0_eis_num

  END FUNCTION get_var

END MODULE mymod

PROGRAM test

  USE mymod
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct

  PRINT *,'This example creates a named variable called `myvar` that &
      &increases by one every time you call it. Use it in expressions &
      & exactly like any other named constant'

  CALL parser%add_variable('myvar', get_var, errcode)
  IF (errcode /= eis_err_none) CALL parser%print_errors()

  DO WHILE(.TRUE.)
    WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
    READ(*,'(A)') input
    ct = parser%evaluate(input, result, errcode)
    IF (errcode == eis_err_none) THEN
      PRINT *,'Result is ', result(1:ct)
    ELSE
      CALL parser%print_errors()
    END IF
  END DO

END PROGRAM test

```

## Parser Simplifier

To improve the performance of the parser it uses an abstract syntax tree based simplification system. This works by converting every operator, variable and function to a node on a tree with each node having subnodes representing the parameters (where relevant). It then recursively goes through those nodes replacing them with a constant value if possible and then rebuilding the simplified tree into a new stack. To calculate the constant value for the simplifier the code evaluates the nodes and passes a `C_PTR_NULL` pointer as the host parameters. This replacement only happens if the node is flagged as being `simplifiable`, otherwise the simplifier simplifies as many nodes as possible and leaves the remaining nodes to be evaluated every time the stack is evaluated. By default all constants, variables and functions are simplifiable. Constants have a constant value so are always simplifiable, but the `add_variable` and `add_function` functions have an optional logical parameter called `can_simplify`. If `can_simplify` is set to `.FALSE.` when adding a variable or function then the simplifier will not simplify a tree node containing this function or variable. By default variables are flagged as not being simplifiable and functions are flagged as being simplifiable but either behaviour can be overriden.

It is also possible to turn off simplification for a parser at various points

1. By passing `should_simplify = .FALSE.` to the `init` method of a parser. This will mean that by default no simplification of any stacks will be performed
2. By passing `simplify = .FALSE.` to the `tokenize` method of a parser then no simplification of the stack produced in that tokenization is performed. If the parser default simplification was set to `.FALSE.` in `init` then setting `simplify = .TRUE` here turns it on for this stack.
3. By passing `simplify = .FALSE.` to the `evaluate` method of a parser when evaluating a string (*NOT* a stack) no simplification of the stack will take place before it is evaluated.
4. A getter function can also set the `status_code` parameter to `eis_status_no_simplify` to prevent simplification of a tree node during the simplification stage.

## Using Host Parameters

Host parameters are parameters that are specified at the point that you call the evaluate method of the parser object and are passed to all of the getter functions that are called as the stack evaluates. They provide a simple way of making information available in getter functions in a generic fashion. Typically you use them to do things like specify a location in space, or the positions of particles etc but the only restriction is that since the host parameters are specified as a `BIND(C)` type you can only pass information that you can put in a `BIND(C)` type. It is important to note that host parameters are not the only way that you can pass data to getter functions. The getter functions remain a full part of the host code and have access to module variables in the normal way. Host parameters are mostly useful because they can be "prepared" for a specific call of the parser.
 
The classic example of using host parameters is to define a position in a spatial domain and then use the host code to iterate over that domain. This allows a user to define an expression in terms of spatial variables. In EIS terms this is again specifying a variable, but we are now using the host parameters option to specify the location in the domain. To do this we need to specify

1. A `BIND(C)` type to store the information for what point in the spatial domain the host code wants to consider

2. A getter function for the variable that reads the data from that type

The first is a simple Fortran Type, but it does have to be flagged as a C interoperable type and comply with the Fortran/C interoperability rules for types. The next section explains why this is required, for the moment just do it. The requirements for what can be in an interoperable type are quite strict and depend on the Fortran standard that you want to follow but if you stick to simple values, other interoperable types and arrays of fixed size then you should have no problems. If you are using Fortran/C interoperability then in general you will want to use the intrinsic `ISO\_C\_BINDING` module (although it isn't needed for everything). To mark a type as C interoperable simply add `BIND(C)` to the definition.

```fortran
  TYPE, BIND(C) :: data_item
    REAL(eis_num) :: x = 0.0_eis_num
    REAL(eis_num) :: y = 0.0_eis_num
  END TYPE data_item
```

In this case my type contains two reals of kind `eis_num`. I didn't have to use an EIS defined kind, I've just chosen to do so here because it means that I'm passing my data at the same precision as EIS is using for calculation. I now need to create two Fortran functions that will be called when a user requests my `x` and `y` data. These getter functions have the same structure as for a simple variable

```fortran
  FUNCTION getter(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
```

This is the definition of a Fortran function that is called by EIS when ever any function or variable is evaluated. Note that this function is also defined `BIND(C)` because it is possible to specify functions for the parser from C code. The function takes 3 parameters and returns 3 things, two through the argument list and one as the function result. The `nparams` argument is the number of parameters that were passed to a function and are irrelevant here because we are going to define a parser variable not a parser function but the underlying Fortran function is the same. `params` is an array containing the parameters that are passed to a parser function. Again they are not used here because we are defining a variable. `host_params` is going to be used here. It is a `C_PTR`type, that is a C pointer that is going to contain the reference to the `data_item` type that we are going to pass in. We use the `C_F_POINTER` function from `ISO_C_BINDING` to convert a C pointer back into an instance of our `data_item` type.

The final thing to do is slightly modify our call to `evaluate`. We create an instance of our `data_item` type and then loop over our domain specifying values for it at a set of control points. Then we get a pointer to it using the `C_LOC` function from `ISO_C_BINDING` and then pass it to the `host_params` optional argument to the `evaluate` method of our parser.

```fortran
MODULE mymod

  USE ISO_C_BINDING
  USE eis_parser_header

  TYPE, BIND(C) :: data_item
    REAL(eis_num) :: x = 0.0_eis_num
    REAL(eis_num) :: y = 0.0_eis_num
  END TYPE data_item

  CONTAINS

  FUNCTION get_x(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
    TYPE(data_item), POINTER :: dat

    IF (.NOT. C_ASSOCIATED(host_params)) RETURN
    CALL C_F_POINTER(host_params, dat)
    res = dat%x

  END FUNCTION get_x



  FUNCTION get_y(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
    TYPE(data_item), POINTER :: dat

    IF (.NOT. C_ASSOCIATED(host_params)) RETURN
    CALL C_F_POINTER(host_params, dat)
    res = dat%y

  END FUNCTION get_y

END MODULE mymod


PROGRAM test

  USE mymod
  TYPE(eis_parser) :: parser
  TYPE(eis_stack) :: stack
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct, ix, iy, it
  TYPE(data_item), TARGET :: item
  CHARACTER(LEN=:), ALLOCATABLE :: str

  PRINT *,'This example uses host parameters to evaluate an expression. &
      &Specify an expression involving `x` and/or `y` and it will &
      &be evaluated on  the domain [[0,1],[0,1]]. The result will be written &
      &to a formatter file called `fort.10`'

  CALL parser%add_variable('x', get_x, errcode)
  CALL parser%add_variable('y', get_y, errcode)

  WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
  READ(*,'(A)') input
  CALL parser%tokenize(input, stack, errcode)
  IF (errcode /= eis_err_none) THEN
    CALL parser%print_errors()
    STOP
  END IF
  ct = parser%evaluate(stack, result, errcode, host_params = C_LOC(item))
  IF (errcode /= eis_err_none) THEN
    CALL parser%print_errors()
    STOP
  END IF
  DO iy = 1, 100
    item%y = REAL(iy-1, eis_num)/99.0_eis_num
    DO ix = 1 , 100
      item%x = REAL(ix-1, eis_num)/99.0_eis_num
      ct = parser%evaluate(stack, result, errcode, host_params = C_LOC(item))
      WRITE(10,*) result(1)
    END DO
  END DO

  DEALLOCATE(result)

END PROGRAM test
```

This test code will evaluate an expression using `x` and `y` to specify the location in a 2D spatial domain with each axis running from 0->1. The expression that you enter will be written to a file called `fort.10` in formatted form in Fortran column major ordering. Reading the data will show that it contains the function that you defined in your expression.

*It is important to note that even if you always specify host parameters there may be occasions where EIS will call a getter function with the host parameters set to `C_NULL_PTR` so if your getter functions use the host parameters they shoud always test for this and deal with it accordingly.*

## Adding functions

Functions take parameters that are specified by the user and act on those parameters to return a value. Functions are defined by the same getter functions as variables, and you can access the parameters that the user specified through the `params` argument to the getter function. The parameters are in left to right order in elements 1 to `nparams` of the `params` array. The array already contains the completely evaluated numerical versions of the parameters and it is not presently possible to access the original user supplied string representations of the parameters to a function.

You add the function by calling the `add_function` method of the parser object. This method has the same parameters as `add_variable` but also adds the optional `expected_params` argument. This argument specifies how many parameters the function expects to take. 
If the `expected_params` parameter is specified then the function will automatically report an error if fewer parameters are provided than expected. If `expected_params` is not specified then the number of parameters to the function cannot be tested automatically. These functions are called variadic functions and they report the number of parameters that they were actually called with in the `nparams` parameter. Do *NOT* use the size of the `params` array to infer the number of parameters to a variadic function since it is not guaranteed to be correct. If a variadic function has been called with an incorrect number of parameters then it should set the `errcode` parameter to `eis_err_wrong_parameters`.

```fortran
MODULE mymod

  USE ISO_C_BINDING
  USE eis_parser_header

  TYPE, BIND(C) :: data_item
    REAL(eis_num) :: x = 0.0_eis_num
    REAL(eis_num) :: y = 0.0_eis_num
  END TYPE data_item

  CONTAINS

  !Function to implement the Cauchy distribution
  !https://en.wikipedia.org/wiki/Cauchy_distribution
  FUNCTION cauchy_dist(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
    REAL(eis_num), PARAMETER :: pi = 4.0_eis_num * ATAN(1.0_eis_num)

    !params(1) - x, dependent variable
    !params(2) - x0, location parameter
    !params(3) - gamma, scale parameter

    res = 1.0/(pi * params(3)) * (params(3)**2 / (params(1) - params(2))**2 &
        + params(3)**2)

  END FUNCTION cauchy_dist



  FUNCTION get_x(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
    TYPE(data_item), POINTER :: dat

    IF (.NOT. C_ASSOCIATED(host_params)) RETURN
    CALL C_F_POINTER(host_params, dat)
    res = dat%x

  END FUNCTION get_x


  FUNCTION get_y(nparams, params, host_params, status_code, errcode) &
      RESULT(res) BIND(C)
    INTEGER(eis_i4), VALUE, INTENT(IN) :: nparams
    REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    REAL(eis_num) :: res
    TYPE(data_item), POINTER :: dat

    IF (.NOT. C_ASSOCIATED(host_params)) RETURN
    CALL C_F_POINTER(host_params, dat)
    res = dat%y

  END FUNCTION get_y

END MODULE mymod


PROGRAM test

  USE mymod
  TYPE(eis_parser) :: parser
  TYPE(eis_stack) :: stack
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct, ix, iy, it
  TYPE(data_item), TARGET :: item
  CHARACTER(LEN=:), ALLOCATABLE :: str

  PRINT *,'This is a version of demo6 but implements a custom function called &
      &`cauchy` that calculates the cauchy distributiong. It takes 3 &
      &parameters. The first parameter is the location to evaluate the &
      &function at, the second is the x origin of the ray and the third is &
      &the gamma parameter'

  CALL parser%add_variable('x', get_x, errcode)
  CALL parser%add_variable('y', get_y, errcode)
  CALL parser%add_function('cauchy', cauchy_dist, errcode, expected_params = 3)

  WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
  READ(*,'(A)') input
  CALL parser%tokenize(input, stack, errcode)
  IF (errcode /= eis_err_none) THEN
    CALL parser%print_errors()
    STOP
  END IF
  ct = parser%evaluate(stack, result, errcode, host_params = C_LOC(item))
  IF (errcode /= eis_err_none) THEN
    CALL parser%print_errors()
    STOP
  END IF
  DO iy = 1, 100
    item%y = REAL(iy-1, eis_num)/99.0_eis_num
    DO ix = 1 , 100
      item%x = REAL(ix-1, eis_num)/99.0_eis_num
      ct = parser%evaluate(stack, result, errcode, host_params = C_LOC(item))
      WRITE(10,*) result(1)
    END DO
  END DO

  DEALLOCATE(result)

END PROGRAM test
```

## Errors in getter functions

All getter functions can report errors that occur when they are evaluating variables or functions. The current errors that should be reported by a getter function are

* `eis_err_wrong_parameters` Wrong number of parameters supplied to a function
* `eis_err_maths_domain` Parameter to this function is mathematically invalid (log of negative number etc.)
* `eis_err_out_of_range` Parameter to this function is out of valid range in a non-mathematical way
* `eis_err_bad_value` Parameter to this function is invalid in some non-mathematical way

## Stack variables

As well as normal variables that are defined by a getter function there are also stack variables. Stack variables are a way of mapping a parser expression to an existing stack. This allows a host code to allow a user to save stacks for later reuse. Stack variables are *NOT* implemented by evaluating the stack and then storing the resulting value but by storing the stack that is provided and pasting it in to the new stack where the label appears.

This means that stack variables have exactly the same behaviour as typing the string that created the stack variable into the string that is using the stack variable. Stack variables are created by a call to the `add_stack_variable` method of the parser object. They can be defined either from a valid deck string or from an existing stack. This means that only stack variables returning a single value can validly be used in mathematical expressions

```fortran
PROGRAM test

  USE eis_parser_header
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct

  PRINT *,'This example demonstrates using stack variables to store a value &
      &that a user provides and making it available for later use. First &
      &specify an expression that evaluates to a single value. That expression &
      &is then stored under the name `stackvar` and can be used in the second &
      &part of the code. NB stackvar is NOT just storing the value of the &
      &expression and returning it but storing the stack from your expression &
      &and putting it in place when you use it by name. Functions and &
      &variables that have changing values will change as expected'

  WRITE(*,'(A)', ADVANCE = 'NO') "Input expression for storage :"
  READ(*,'(A)') input

  CALL parser%add_stack_variable('stackvar', input, errcode)
  IF (errcode /= eis_err_none) THEN
    CALL parser%print_errors()
    STOP
  END IF
  PRINT *,'Expression is stored as "stackvar"'

  DO WHILE(.TRUE.)
    WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
    READ(*,'(A)') input
    ct = parser%evaluate(input, result, errcode)
    IF (errcode == eis_err_none) THEN
      PRINT *,'Result is ', result(1:ct)
    ELSE
      CALL parser%print_errors()
    END IF
  END DO

END PROGRAM test

```

## Deferred constants/variables/stack variables/functions

Constants, variables, stack variables and functions can be introduced into the parser as `deferred`. Deferred items are items that have _names_ registered to them but not _implementations_. This means that it is valid to tokenize expressions to stacks that contain deferred items but is not valid to evaluate the stacks (or evaluate string expressions involving deferred items directly) until actual implementations are provided.

To specify deferred items simply use a call to `add_constant`, `add_variable`, `add_stack_variable` or `add_function` without specifying the value of the constant, the getter function for variables or functions or the stack for stack variables. To then provide an implementation just make a normal call to `add_constant`, `add_variable`, `add_stack_variable` or `add_function` specifying the values, getter functions or stacks.

## Emplaced functions

Stack variables allow replacing a single name with an existing stack, but sometimes you want to allow the user to specify which stack to provide based on parameters to a function. For example in the EPOCH code that EIS originally comes from you specify the `density` function with a parameter for the name of the species to retrieve the density of. This provides the stack for the density of the relevant species.

Emplaced functions work much like normal functions but are defined by a different getter function, normally termed an _emplacement function_.
```fortran
    SUBROUTINE parser_emplace_fn(orig_string, nparams, params, host_params, &
        stack_out, status_code, errcode)
      IMPORT eis_num, eis_i4, C_PTR, eis_stack, eis_error, eis_status
      CHARACTER(LEN=*), INTENT(IN) :: orig_string
      INTEGER, INTENT(IN) :: nparams
      REAL(eis_num), DIMENSION(nparams), INTENT(IN) :: params
      TYPE(C_PTR), INTENT(IN) :: host_params
      TYPE(eis_stack), INTENT(INOUT) :: stack_out
      INTEGER(eis_status), INTENT(INOUT) :: status_code
      INTEGER(eis_error), INTENT(INOUT) :: errcode
    END SUBROUTINE parser_emplace_fn
```
This getter is very similar to the one for normal functions but now no longer returns a value, has an extra parameter `stack_out` and tells you the exact symbol that was encountered to cause the emplacement action in the `orig_string` parameter. As usual, you can access the parameters to the function using the `params` array and you can access the host code parameters through the `host_params`. You should use the information from these two sources to select a stack variable and set the `stack_out` parameter equal to that stack. If the parameters are invalid then error codes should be returned in the same way as for a normal function.

When a user specifies an emplaced function in an expression it produces a special emplacement item in the produced stack. Until an _emplacement action_ is performed on the stack it is not valid and cannot be executed. You can cause emplacement of a stack by using the `emplace` method of the parser object. The emplace method optionally takes a `host_params` argument that is passed to the emplacement function. By default the `emplace` method permanently changes the stack that is passed to it, removing the emplacement item from the stack and replacing it with the stack that is returned from the emplacement function. You can optionally specify another stack in the `destination` argument to the `emplace` method and that will cause the emplaced, valid stack to be created in the specified `destination` stack and leave the original stack with the emplacement item so it can be emplaced multiple times.

`orig_string` is used to allow you to have several different strings that will trigger the emplacement action. This is particularly useful if you want to be able to have an emplacement function where the symbol that should cause emplacement is determined from user input rather than already known to the host code.

If you use the version of the `evaluate` method that takes a string rather than a stack and the string includes emplaced functions then the emplacement will happen automatically during evaluation. This behaviour does _not_ happen with the version of evaluate that takes a stack since the stack would be permanently changed by the emplacement.

## Changing a parser item

You can change the behaviour of a parser item by simply calling `add_constant`, `add_variable`, `add_function` or `add_stack_variable`again with the same name but a different value or getter function. The previous behaviour for that name is forgotten and all future stacks that are tokenized by this parser will use the new behaviour. Stacks that have _already_ been tokenized by this parser are unaffected and will continue to evaluate with the original values and getter functions in place. If you want to be able to change the behaviour of a stack after it has been tokenized you will have to use emplaced functions.

There is no way to prevent this overriding behaviour in the parser but a host code can check if a symbol is already known to the parser using the `get_symbol_info` function. This takes a string holding the name of the symbol to test and returns a logical for whether or not the symbol is known to the parser. It will return `.TRUE.` if the requested symbol is a variable, constant, function, operator or emplacement function regardless of whether the symbol is currently deferred or not. Optionally you can specify a `cap_bits` parameter that will be filled with the `cap_bits` value specified when the symbol was defined or the `deferred` option that is set to `.TRUE.` if the symbol is deferred and `.FALSE.` if not.

## Capability bits

Quite commonly you will want to flag a stack as having certain effects. Examples of this would be flagging a stack as being time varying or space varying. This can be automated for you by using _capability bits_. Capability bits are a 64 bit bitmask that you can optionally specify to any variables, functions or constants using the `cap_bits` optional parameter to `add_variable`, `add_function` or `add_constant`. When a stack is generated the `cap_bits` parameter of the `eis_stack` object is set to be the bitwise OR of the `cap_bits` of all of the elements that make up the stack. So if a variable that indicates `time` is specified and sets the `is_time_varying` capability bit then any stack containing that variable will be flagged as time varying automatically.

## Multiple Parser Objects

Parsers are, by default, fully self contained. Changes to one parser do not make changes to another parser. Adding a function, variable or constant to a parser only adds it to that parser by default and all other parsers will still be unaware of your newly added item. You can override this behaviour and add an item to all parsers by setting the `global` optional parameter to `add_constant`, `add_variable`, `add_function`, `add_stack_variable` and `add_emplaced_function` to `.TRUE.`. Items are searched for in each parser's local list of items before checking the global list so you can hide global items for a single parser by adding an item with the same name without the `global` flag for that parser.

As a consequence of this separation care has to be taken when evaluating a stack with one parser that was created with a different parser. Stacks that do not contain deferred or emplaced functions will evaluate as expected if evaluated with a different parser since the stack elements contain pointers to their evaluation functions once they are unambiguously known. Stacks that do contain emplaced or deferred items will attempt to use the list of names and associated constants, getter functions or stacks from the parser that you either evaluate or emplace them against.

As a general rule it is recommended that codes use only a single parser object unless they have a definite reason to do otherwise

## Parsers and thread safety

Once a parser object has been initialised and had all constants, variables, functions etc. created the code for tokenization and evaluation is reentrant and is thread safe so long as all the getter functions are themselves thread safe. The getter functions for the core code are thread safe.

To use a single parser in multiple threads you *have* to call the `init` method manually on a single thread before using the parser and add all constants, functions, variables etc. on a single thread. If your code needs to add parser items from multiple threads then this must either be done in a critical section or you should use one parser per thread.

## Overriding the built in parser items

The built in parser items are just added to the global lists of constants, variables and functions when the parser is initialised. As such they can be overriden by custom items simply by specifying items with the same name. If you specify an item with the same name as a global item no warning is given.

## Parser result functions

Sometimes a host code might want to be able to just specify a function that returns the values from a stack rather than evaluating a textual expression. This might be to provide higher performance for common operations, to allow the code to override user specified expressions or to allow tying of a scripting language to a program using the EIS parser system. This is supported through a parser result function which must have the signature

```fortran
    SUBROUTINE parser_result_function(nresults, results, host_params, &
        status_code, errcode) BIND(C)
      IMPORT eis_num, eis_i4, C_PTR, eis_error, eis_status
      INTEGER, INTENT(INOUT) :: nresults
      REAL(eis_num), DIMENSION(nresults), INTENT(OUT) :: results
      TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
      INTEGER(eis_status), INTENT(INOUT) :: status_code
      INTEGER(eis_error), INTENT(INOUT) :: errcode
    END SUBROUTINE
```

You then call the parser function `set_result_function` to bind a given result function to a stack. When this stack is then evaluated the result function will be called. The result function is handed a `host_param` object the same as the normal getter functions are which are the host parameters specified when the stack is executed. The result function should return one or more results through the `results` array argument and set the `nresults` argument to the number of results returned or return an error code. The initial value of `nresults` is the size of the `results` array. If this size is insufficient to return the number of results wanted then `nresults` should be set to the desired number of results and the `results` array should not be populated. The parser will reallocate the results array to the desired size and recall the result function. If the number of returned items is not constant then behaviour should be implemented in the result function to deal with this call/recall behaviour or the result function is not guaranteed to ever terminate. No guarantee is made on the first value of `nresults` other than it will be 1 or greater. Stacks that return values using result functions may be stored as stack variables but must only return a single value if they are to be used in mathematical expressions.

Errors should be returned through the `errcode` parameter in the usual way.


```fortran
MODULE mymod

  USE ISO_C_BINDING
  USE eis_parser_header

  TYPE, BIND(C) :: data_item
    REAL(eis_num) :: x = 0.0_eis_num
    REAL(eis_num) :: y = 0.0_eis_num
  END TYPE data_item

  CONTAINS

  SUBROUTINE get_values(nvalues, values, host_params, status_code, errcode) &
      BIND(C)

    INTEGER(eis_i4), INTENT(INOUT) :: nvalues
    REAL(eis_num), DIMENSION(nvalues), INTENT(OUT) :: values
    TYPE(C_PTR), VALUE, INTENT(IN) :: host_params
    INTEGER(eis_status), INTENT(INOUT) :: status_code
    INTEGER(eis_error), INTENT(INOUT) :: errcode
    TYPE(data_item), POINTER :: dat
    REAL(eis_num), PARAMETER :: pi = 4.0_eis_num * ATAN(1.0_eis_num)

    IF (.NOT. C_ASSOCIATED(host_params)) RETURN
    CALL C_F_POINTER(host_params, dat)
    values(1) = SIN(4.0_eis_num * pi * (dat%x-0.5_eis_num)) * COS(6.0_eis_num*pi*(dat%y-0.5_eis_num))
    nvalues = 1

  END SUBROUTINE get_values

END MODULE mymod


PROGRAM test

  USE mymod
  TYPE(eis_parser) :: parser
  TYPE(eis_stack) :: stack
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct, ix, iy, it
  TYPE(data_item), TARGET :: item
  CHARACTER(LEN=:), ALLOCATABLE :: str

  PRINT *,'This example makes use of a result function to show how to have &
      &EIS return a stack with a value that is returned by a host code &
      &provided function rather than a user provided stack. As with previous &
      &examples it writes a function to "fort.10" but the result is returned &
      &from the "get_values" function rather than a text mode stack. Note that &
      &no text stack needs to be created, the result function can be bound &
      &directly to an unused stack.'

  CALL parser%set_result_function(get_values, stack, errcode)
  DO iy = 1, 100
    item%y = REAL(iy-1, eis_num)/99.0_eis_num
    DO ix = 1 , 100
      item%x = REAL(ix-1, eis_num)/99.0_eis_num
      ct = parser%evaluate(stack, result, errcode, host_params = C_LOC(item))
      WRITE(10,*) result(1)
    END DO
  END DO

  DEALLOCATE(result)

END PROGRAM test
```

## Pointer variables

It is possible to specify a parser variable using a Fortran POINTER variable rather than a getter function. The parser will keep a reference to the pointer and always return the current version of the variable when a stack using the symbol is executed (unless the variable is flagged as simplifiable in which case it will return the value at the point where the stack is simplified). If the parser is compiled under the Fortran 2008 standard then you can specify TARGET variables as well as POINTER variables. You specify pointer variables using the `add_pointer_variable` method of the parser object. It takes all of the same parameters as `add_variable` except for the getter function which is replaced with a pointer to the variable to be associated with the name. The pointer variable can be a 32 bit integer, a 64 bit integer, a 32 bit real or a 64 bit real.

```fortran
PROGRAM test

  USE eis_parser_header
  IMPLICIT NONE
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=1000) :: input
  INTEGER(eis_error) :: errcode
  REAL(eis_num), DIMENSION(:), ALLOCATABLE :: result
  INTEGER :: ct
  INTEGER, POINTER :: ptrvar
  INTEGER(eis_bitmask) :: cbits

  PRINT *,'This shows an example of using pointer variables. Pointer variables &
      &are variables that work by holding a pointer to a variable in your code &
      &and having the *current* value of that variable be returned when &
      &a maths expression involving the pointer variable is encountered. In &
      &order to work correctly your pointer must have a lifespan as long as &
      &the parser object that makes use of it'

  ALLOCATE(ptrvar)
  ptrvar = 100
  errcode = eis_err_none

  CALL parser%init(errcode, physics = eis_physics_si)a
  IF (errcode /= eis_err_none) CALL parser%print_errors()
  !Create a parser pointer variable and set it to have a
  !capability bit value of 1
  CALL parser%add_pointer_variable('ptrvar', ptrvar, errcode, &
      cap_bits = 1_eis_bitmask)

  DO WHILE(.TRUE.)
    WRITE(*,'(A)', ADVANCE = 'NO') "Please input a mathematical expression :"
    READ(*,'(A)') input
    IF (input == 'exit') EXIT
    ct = parser%evaluate(input, result, errcode, cap_bits = cbits)
    IF (errcode == eis_err_none) THEN
      PRINT *,'Result is ', result(1:ct)
      !If expression used ptrvar (and hence has capability bit of 1)
      !increment ptrvar
      IF (cbits == 1_eis_bitmask) ptrvar = ptrvar + 1
    ELSE
      CALL parser%print_errors()
    END IF
  END DO

END PROGRAM test
```
This simple example code uses capability bits to identify when an expression using the pointer variable is used and increments the pointer by one every time. The result of repeatedly evaluting expressions involving `ptrvar` shows that it automatically reflects the changes.

Pointer variables are very powerful but they have some substantial drawbacks. EIS can't check that the pointer that you handed it is still valid when you execute the stack. In fact since the pointer is carried around with the stack element that is generated by using the pointer variable in an expression, if the pointer is deallocated and reallocated then every stack created that used the pointer variable will now be invalid and cannot be fixed without being reparsed.

The Fortran 2008 version using TARGET variables is less susceptible to this type error but has it's own problems. The Fortran 2008 standard guarantees that the way in which EIS takes a pointer to a TARGET variable is correct and will always refer to the true variable but it is valid to pass non-TARGET variables to the `add_pointer_variable` function as well. If you do so then the behaviour is unpredictable. The code might work as expected, it might crash or you might get strange hard to debug errors. The ability to have EIS simply return the value of a variable in response to a symbol is very powerful but it comes with significant downsides so the getter functions are considered the main method of defining variables in EIS.

As a final note developers are reminded that TARGET and POINTER variables may reduce the compiler's scope for optimising code.

## Descriptions

When adding any symbol to the parser you can optionally provide a description to go with it. This is done by providing a string variable or literal as the optional parameter `description` when adding any key. Descriptions are not persistent and if a symbol is redefined then it's description is lost unless it is resupplied. Descriptions are retreived in various ways but mainly through the use of the `get_structure_as_markdown` method of the parser object. This method takes an allocatable string and an optional title and returns a sectioned common markdown document detailing all of the symbols that the parser understands as a string.

```fortran
PROGRAM test
  
  USE eis_parser_mod
  USE eis_parser_header
  USE eis_header
  IMPLICIT NONE
  TYPE(eis_parser) :: parser
  CHARACTER(LEN=:), ALLOCATABLE :: md
  INTEGER(eis_error) :: errcode

  CALL parser%init(errcode, physics = eis_physics_si)
  CALL parser%get_structure_as_markdown(md, title='Maths parser description')
  WRITE(*,'(A)') md
  DEALLOCATE(md)

END PROGRAM test
```
